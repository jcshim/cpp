## 강의목표
- **LightSQL 라이브러리 이해**: LightSQL의 개념과 특징을 이해하고, C++에서 경량 SQL 데이터베이스 연동을 위한 기본 사용법을 익힙니다.
- **기본 데이터베이스 연동**: LightSQL을 이용해 데이터베이스 연결, 테이블 생성, 데이터 삽입, 조회 등 기본적인 SQL 작업을 수행할 수 있습니다.
- **실습을 통한 적용**: 간단한 예제 프로그램을 통해 LightSQL의 기능을 직접 체험하고, 데이터베이스 연동 및 관리 방법을 학습합니다.

---

## 강의요약
이번 강의에서는 LightSQL 라이브러리를 소개하고, C++ 프로그램 내에서 경량 데이터베이스와 상호작용하는 기본 방법을 다룹니다. LightSQL은 SQLite와 유사한 경량 SQL 데이터베이스 라이브러리로, 간단한 인터페이스를 제공하여 데이터베이스 연결, 쿼리 실행, 결과 처리 등을 쉽게 수행할 수 있습니다. 강의에서는 데이터베이스 파일 생성, 테이블 생성, 데이터 삽입 및 조회의 흐름을 예제를 통해 실습합니다.

---

## 강의내용

### 1. LightSQL 라이브러리 소개
- **개념 및 특징**
  - 경량 SQL 라이브러리로, 복잡한 설정 없이 간편하게 데이터베이스 연동을 할 수 있음.
  - C++에서 SQL 쿼리를 실행하고 결과를 받아오는 기능을 제공.
  - SQLite와 유사한 방식으로 사용되며, 작은 프로젝트나 임베디드 시스템에서 유용함.
- **설치 및 포함**
  - 라이브러리 설치 후, `#include <LightSQL/LightSQL.h>`와 같이 헤더 파일을 포함하여 사용.

### 2. LightSQL 기본 사용법
- **데이터베이스 연결**
  - 데이터베이스 파일을 지정하여 연결을 시도합니다.
  - 연결 성공 여부를 확인하고, 이후 SQL 명령어를 실행.
- **SQL 쿼리 실행**
  - 테이블 생성, 데이터 삽입, 데이터 조회 등 일반 SQL 문을 실행할 수 있습니다.
  - 실행 결과는 컨테이너(예: vector, map 등)로 반환되어, 반복문 등을 통해 각 행의 데이터를 처리할 수 있습니다.
- **예외 처리**
  - 데이터베이스 작업 중 발생할 수 있는 오류에 대해 적절한 예외 처리(try-catch)를 적용합니다.


### 3. C++에서 SQLite3 사용하기 (Visual Studio 기준)  
**1. SQLite 다운로드**

1. 공식 사이트 접속  
👉 [https://www.sqlite.org/download.html](https://www.sqlite.org/download.html)

2. 다음 파일을 다운로드합니다:
- `sqlite-amalgamation-xxxxxx.zip` (※ `xxxxxx`는 버전 번호)
  - 안에 `sqlite3.h`, `sqlite3.c` 파일이 들어 있습니다.
- `sqlite-dll-win64-x64-xxxxxx.zip` (64비트용) 또는  `sqlite-dll-win32-x86-xxxxxx.zip` (32비트용)
  - 안에 `sqlite3.dll` 파일이 들어 있습니다.

**※ 꼭 Windows용 DLL 파일과 amalgamation 파일 둘 다 받아야 합니다!**

다운로드한 압축 파일을 풀면 다음 파일이 필요합니다: `sqlite3.h`  `sqlite3.c`  `sqlite3.dll`

---

**2. 프로젝트에 파일 복사

1. Visual Studio에서 C++ 프로젝트를 생성합니다.  (예: `Project1`라는 이름으로)

2. 아래 파일을 **프로젝트 폴더**에 복사합니다:
- `sqlite3.h` 
- `sqlite3.c`
- `sqlite3.dll`  

   (예: `C:\Users\...\source\repos\Project1\`)

3. Visual Studio에서 **프로젝트**에 파일 추가:
   - 솔루션 탐색기 → **프로젝트 이름**에 오른쪽 클릭 →  
     **추가(Add)** → **기존 항목(Existing Item)** →  
     `sqlite3.h`와 `sqlite3.c`를 선택 → **확인**

4. `sqlite3.dll` 파일은 별도로 추가할 필요 없습니다.  
   대신, 실행할 때 **빌드 폴더(Debug 또는 Release 폴더)** 안에 복사해 둡니다.  
   (exe 파일과 같은 폴더에 있어야 정상 실행됩니다.)

---

**3. 코드 작성** **소스 코드 상단에 추가:**
```cpp
#include "sqlite3.h"
```
이후 sqlite3 함수를 자유롭게 사용할 수 있습니다.

---

**4. 요약 흐름**
```
1. 공식 사이트에서 sqlite3 다운로드
2. sqlite3.h, sqlite3.c, sqlite3.dll 준비
3. 프로젝트 폴더에 복사
4. sqlite3.h, sqlite3.c는 프로젝트에 추가
5. sqlite3.dll은 실행 파일 옆에 놓기
6. #include "sqlite3.h" 해서 사용
```

---

**📌 추가 주의사항**
- Visual Studio에서 **x64** 설정 시 `sqlite-dll-win64-x64-xxxxxx.zip`을 받아야 합니다.
- Visual Studio에서 **x86** 설정 시 `sqlite-dll-win32-x86-xxxxxx.zip`을 받아야 합니다.
- `sqlite3.c`는 **컴파일 대상**에 추가되어야 합니다.


### 4. 간단한 데이터베이스 연동 예제
- **예제 시나리오**
  - `"sample.db"` 파일에 연결 후, `Users` 테이블을 생성합니다.
  - `Users` 테이블에 사용자 정보(예: 이름, 나이)를 삽입하고, 데이터를 조회하여 출력합니다.

---

## 실전예제

```cpp
#include <iostream>
#include "sqlite3.h"    // 진짜 sqlite3 라이브러리 사용
#include <string>
using namespace std;

int main() {
    sqlite3* db;            // 데이터베이스 객체
    char* errMsg = nullptr; // 에러 메시지 포인터
    int rc;                 // 리턴 코드

    // 1. 데이터베이스 연결 (또는 파일 생성)
    rc = sqlite3_open("sample.db", &db);
    if (rc) {
        cerr << "데이터베이스 열기 실패: " << sqlite3_errmsg(db) << endl;
        sqlite3_close(db);
        return 1;
    }

    // 2. 테이블 생성
    const char* createTableQuery =
        "CREATE TABLE IF NOT EXISTS Users ("
        "ID INTEGER PRIMARY KEY AUTOINCREMENT, "
        "Name TEXT, "
        "Age INTEGER);";

    rc = sqlite3_exec(db, createTableQuery, nullptr, nullptr, &errMsg);
    if (rc != SQLITE_OK) {
        cerr << "테이블 생성 실패: " << errMsg << endl;
        sqlite3_free(errMsg);
        sqlite3_close(db);
        return 1;
    }

    // 3. 데이터 삽입
    const char* insertQuery =
        "INSERT INTO Users (Name, Age) VALUES "
        "('Alice', 30), "
        "('Bob', 25);";

    rc = sqlite3_exec(db, insertQuery, nullptr, nullptr, &errMsg);
    if (rc != SQLITE_OK) {
        cerr << "데이터 삽입 실패: " << errMsg << endl;
        sqlite3_free(errMsg);
        sqlite3_close(db);
        return 1;
    }

    // 4. 데이터 조회
    const char* selectQuery = "SELECT * FROM Users;";
    sqlite3_stmt* stmt;

    rc = sqlite3_prepare_v2(db, selectQuery, -1, &stmt, nullptr);
    if (rc != SQLITE_OK) {
        cerr << "쿼리 준비 실패: " << sqlite3_errmsg(db) << endl;
        sqlite3_close(db);
        return 1;
    }

    cout << "Users 테이블 데이터:" << endl;
    while (sqlite3_step(stmt) == SQLITE_ROW) {
        int id = sqlite3_column_int(stmt, 0);
        const unsigned char* name = sqlite3_column_text(stmt, 1);
        int age = sqlite3_column_int(stmt, 2);

        cout << "ID: " << id
            << ", Name: " << (name ? reinterpret_cast<const char*>(name) : "NULL")
            << ", Age: " << age << endl;
    }

    // 5. 리소스 해제
    sqlite3_finalize(stmt);
    sqlite3_close(db);

    return 0;
}
```

**예제 설명**:
- **데이터베이스 연결**:  
  - `LightSQL::Database db("sample.db");`를 통해 `sample.db` 파일에 연결하고, `open()` 함수로 연결 성공 여부를 확인합니다.
- **테이블 생성**:  
  - `CREATE TABLE IF NOT EXISTS Users ...` SQL 문을 통해 `Users` 테이블을 생성합니다.
- **데이터 삽입**:  
  - `INSERT INTO Users ...` SQL 문을 실행하여 샘플 데이터를 추가합니다.
- **데이터 조회**:  
  - `SELECT * FROM Users;` 쿼리를 실행하여 결과를 `vector<map<string, string>>` 형태로 받아 각 행의 데이터를 출력합니다.
- **연결 종료**:  
  - 데이터베이스 작업이 끝난 후 `db.close()`를 호출하여 연결을 종료합니다.

---

이번 강의에서는 LightSQL 라이브러리를 활용하여 경량 데이터베이스 연동의 기본 과정을 학습합니다. 예제 코드를 직접 작성하고 실행해 보면서, 데이터베이스 연결, 테이블 관리, 데이터 삽입 및 조회의 전반적인 흐름을 체험하시기 바랍니다.
