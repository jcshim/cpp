C++에서 **상속(Inheritance)** 과 관련된 주요 키워드를 정리하면 다음과 같습니다.

---

### 🔹 **기본적인 상속 관련 키워드**
1. **`class`**  
   - 클래스를 정의하는 키워드로, 기본 클래스(부모 클래스)와 파생 클래스(자식 클래스)를 선언할 때 사용됩니다.

2. **`public`, `protected`, `private` (접근 지정자)**  
   - 상속 시 기본 클래스의 멤버 접근 권한을 변경할 수 있습니다.
   - 기본적으로 `private` 멤버는 상속되지 않으며, `protected`와 `public` 멤버만 상속됩니다.

| 상속 방식 | 부모 클래스 `public` 멤버 | 부모 클래스 `protected` 멤버 | 부모 클래스 `private` 멤버 |
|-----------|--------------------------|-----------------------------|----------------------------|
| `public` 상속 | `public` 유지 | `protected` 유지 | 접근 불가능 |
| `protected` 상속 | `protected`로 변경 | `protected` 유지 | 접근 불가능 |
| `private` 상속 | `private`로 변경 | `private`로 변경 | 접근 불가능 |

3. **`virtual` (가상 함수 & 가상 상속)**  
   - 가상 함수를 선언할 때 사용되며, 다형성을 구현하기 위해 필요합니다.
   - 가상 상속(다이아몬드 상속 문제 해결)을 위해 `virtual` 키워드를 기본 클래스 앞에 붙일 수 있습니다.

4. **`override` (C++11 이후 추가됨)**  
   - 파생 클래스에서 부모 클래스의 가상 함수를 오버라이드할 때 사용됩니다.
   - 오버라이딩 오류(예: 오타)를 방지하는 역할을 합니다.

5. **`final` (C++11 이후 추가됨)**  
   - 클래스 또는 가상 함수의 오버라이딩을 금지하는 역할을 합니다.
   - `class Derived final {}` → 이 클래스를 상속할 수 없음.
   - `void func() override final;` → 이 함수는 더 이상 오버라이딩할 수 없음.

---

### 🔹 **다이아몬드 상속과 가상 상속**
6. **`virtual` (가상 상속)**  
   - 다중 상속에서 **다이아몬드 문제**를 해결하기 위해 사용됩니다.
   - 가상 상속을 하면 기본 클래스의 인스턴스가 하나만 유지됩니다.
   ```cpp
   class A { /* ... */ };
   class B : virtual public A { /* ... */ };
   class C : virtual public A { /* ... */ };
   class D : public B, public C { /* ... */ };  // A가 하나만 존재함.
   ```

---

### 🔹 **기타 관련 키워드**
7. **`using` (기반 클래스의 생성자 상속 및 멤버 접근 제어)**  
   - 부모 클래스의 생성자를 상속받아 사용할 때 `using`을 사용할 수 있습니다.
   ```cpp
   class Parent {
   public:
       Parent(int x) { /* ... */ }
   };

   class Child : public Parent {
   public:
       using Parent::Parent; // Parent의 생성자를 상속받음.
   };
   ```

8. **`explicit` (명시적 생성자)**  
   - 자동 형변환을 방지하는 생성자 키워드.
   - 상속과 직접적인 관련은 없지만, 파생 클래스에서 생성자 호출 시 영향을 줄 수 있습니다.

9. **`dynamic_cast` (업캐스팅 & 다운캐스팅)**  
   - 다형성을 활용할 때, 포인터/참조를 형 변환하는 키워드입니다.
   ```cpp
   Base* base = new Derived();
   Derived* derived = dynamic_cast<Derived*>(base);
   if (derived) {
       // 변환 성공 시 실행.
   }
   ```

10. **`typeid` (런타임 타입 확인)**  
    - 다형성을 사용할 때, 객체의 실제 타입을 확인할 수 있는 키워드입니다.
    ```cpp
    if (typeid(*ptr) == typeid(Derived)) {
        // ptr이 Derived 클래스의 객체를 가리키는 경우.
    }
    ```

---

### ✅ **정리**
| 키워드 | 설명 |
|--------|------|
| `class` | 클래스 선언 |
| `public`, `protected`, `private` | 상속 접근 지정자 |
| `virtual` | 가상 함수 & 가상 상속 |
| `override` | 오버라이딩 시 오류 방지 (C++11) |
| `final` | 추가 상속/오버라이딩 방지 (C++11) |
| `using` | 부모 클래스 생성자/멤버를 상속하여 사용 |
| `explicit` | 명시적 생성자, 암시적 변환 방지 |
| `dynamic_cast` | 업캐스팅 & 다운캐스팅 |
| `typeid` | 런타임 타입 확인 |

C++에서 상속을 제대로 활용하면 **코드 재사용**과 **다형성**을 극대화할 수 있습니다. 하지만 다중 상속에서는 **다이아몬드 문제**나 **가상 함수 오버라이딩 문제**를 신경 써야 합니다.
