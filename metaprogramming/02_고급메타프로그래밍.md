# ğŸ“˜ 2ì¥. ê³ ê¸‰ ë©”íƒ€í”„ë¡œê·¸ë˜ë° â€“ SFINAEì™€ Concepts

---

## 2.1 SFINAEë€ ë¬´ì—‡ì¸ê°€?

### âœ… ì •ì˜

**SFINAE**ëŠ” \*"Substitution Failure Is Not An Error"\*ì˜ ì•½ìì…ë‹ˆë‹¤.

> í…œí”Œë¦¿ ì¸ì ëŒ€ì…ì´ ì‹¤íŒ¨í•˜ë”ë¼ë„ **ì»´íŒŒì¼ ì—ëŸ¬ê°€ ì•„ë‹Œ ë‹¨ìˆœí•œ ì„ íƒ ì‹¤íŒ¨ë¡œ ê°„ì£¼**ë˜ì–´ ë‹¤ë¥¸ ì˜¤ë²„ë¡œë“œ í›„ë³´ë¥¼ íƒìƒ‰í•˜ê²Œ ë©ë‹ˆë‹¤.

### âœ… ëª©ì 

* íƒ€ì… ì¡°ê±´ì— ë”°ë¼ í…œí”Œë¦¿ í•¨ìˆ˜ì˜ ì‚¬ìš© ì—¬ë¶€ë¥¼ ì»´íŒŒì¼ ì‹œì ì— ê²°ì •
* ì˜ëª»ëœ íƒ€ì… ì‚¬ìš©ì„ **ì»´íŒŒì¼ íƒ€ì„ì— ë°©ì§€**í•  ìˆ˜ ìˆìŒ

---

## 2.2 `std::enable_if`ë¥¼ í™œìš©í•œ ì˜ˆì‹œ

```cpp
#include <type_traits>
#include <iostream>

template <typename T>
typename std::enable_if<std::is_integral<T>::value, void>::type
printType(T value) {
    std::cout << "ì •ìˆ˜í˜•ì…ë‹ˆë‹¤: " << value << "\n";
}

template <typename T>
typename std::enable_if<std::is_floating_point<T>::value, void>::type
printType(T value) {
    std::cout << "ì‹¤ìˆ˜í˜•ì…ë‹ˆë‹¤: " << value << "\n";
}

int main() {
    printType(10);     // ì •ìˆ˜í˜•ì…ë‹ˆë‹¤
    printType(3.14);   // ì‹¤ìˆ˜í˜•ì…ë‹ˆë‹¤
}
```

---

## 2.3 `if constexpr` (C++17\~)

ë³´ë‹¤ ê°„ë‹¨í•˜ê²Œ ì¡°ê±´ ë¶„ê¸°ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆë„ë¡ C++17ë¶€í„° \*\*`if constexpr`\*\*ì´ ë„ì…ë˜ì—ˆìŠµë‹ˆë‹¤.

```cpp
template <typename T>
void print(T val) {
    if constexpr (std::is_pointer<T>::value)
        std::cout << "í¬ì¸í„°ì…ë‹ˆë‹¤\n";
    else
        std::cout << "í¬ì¸í„°ê°€ ì•„ë‹™ë‹ˆë‹¤\n";
}
```

---

## 2.4 Concepts (C++20\~)

### âœ… ì •ì˜

**Concepts**ëŠ” í…œí”Œë¦¿ íƒ€ì… ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•œ **ëª…ì‹œì ì¸ ì¡°ê±´**ì„ ì§€ì •í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.
â†’ ì½”ë“œ ê°€ë…ì„± í–¥ìƒ, ì˜¤ë¥˜ ë©”ì‹œì§€ ëª…í™•í™”

---

### âœ… ì˜ˆì œ: `Integral` Concept

```cpp
#include <concepts>
#include <iostream>

template<typename T>
concept Integral = std::is_integral_v<T>;

template<Integral T>
T add(T a, T b) {
    return a + b;
}

int main() {
    std::cout << add(10, 20);   // OK
    // std::cout << add(3.14, 2.5); // ì»´íŒŒì¼ ì—ëŸ¬ (ì‹¤ìˆ˜í˜•ì€ Integral ì•„ë‹˜)
}
```

---

## 2.5 ì‚¬ìš©ì ì •ì˜ Concept

```cpp
template<typename T>
concept HasToString = requires(T a) {
    { a.toString() } -> std::convertible_to<std::string>;
};

struct MyClass {
    std::string toString() const { return "Hello"; }
};

template<HasToString T>
void printString(const T& obj) {
    std::cout << obj.toString() << "\n";
}
```

---

## 2.6 ì‹¤ìŠµ ë¬¸ì œ

1. `std::enable_if`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì§ìˆ˜ë§Œ ì¶œë ¥í•˜ëŠ” í•¨ìˆ˜ `printEven(int n)`ì„ ì‘ì„±í•˜ì‹œì˜¤.
2. `if constexpr`ë¥¼ ì‚¬ìš©í•˜ì—¬ `í¬ì¸í„° ì—¬ë¶€`ë¥¼ íŒë‹¨í•˜ëŠ” í…œí”Œë¦¿ í•¨ìˆ˜ë¥¼ ì‘ì„±í•˜ì‹œì˜¤.
3. `FloatingPoint` conceptì„ ì •ì˜í•˜ê³ , float ë˜ëŠ” doubleë§Œ í—ˆìš©í•˜ëŠ” `divide(a, b)` í•¨ìˆ˜ë¥¼ ì‘ì„±í•˜ì‹œì˜¤.
4. `requires`ë¥¼ ì´ìš©í•´ `has_size()` í•¨ìˆ˜ë¥¼ ê°€ì§„ íƒ€ì…ë§Œ ë°›ì•„ ì¶œë ¥í•˜ëŠ” í…œí”Œë¦¿ í•¨ìˆ˜ë¥¼ ì‘ì„±í•˜ì‹œì˜¤.

---

## 2.7 ì •ë¦¬

| ê°œë…               | ì„¤ëª…                                    |
| ---------------- | ------------------------------------- |
| SFINAE           | í…œí”Œë¦¿ ì¸ì ëŒ€ì… ì‹¤íŒ¨ ì‹œ ë‹¤ë¥¸ í›„ë³´ë¥¼ ì„ íƒí•˜ê²Œ í•˜ëŠ” ì»´íŒŒì¼ ê·œì¹™  |
| `std::enable_if` | ì¡°ê±´ë¶€ í…œí”Œë¦¿ í™œì„±í™”                           |
| `if constexpr`   | ì¡°ê±´ì— ë”°ë¥¸ ì»´íŒŒì¼ íƒ€ì„ ì½”ë“œ ë¶„ê¸°                   |
| Concepts         | íƒ€ì… ì¡°ê±´ì„ ëª…í™•í•˜ê²Œ í‘œí˜„í•˜ì—¬ ì•ˆì „í•˜ê³  ì½ê¸° ì‰¬ìš´ í…œí”Œë¦¿ ì½”ë“œ êµ¬í˜„ |

---

> ğŸ’¡ **í•œ ì¤„ ìš”ì•½**:
> *â€œê³ ê¸‰ ë©”íƒ€í”„ë¡œê·¸ë˜ë°ì€ ì¡°ê±´ê³¼ íƒ€ì… ì œì•½ì„ í†µí•´ í…œí”Œë¦¿ ì½”ë“œì˜ ì•ˆì „ì„±ê³¼ ëª…í™•ì„±ì„ ë†’ì´ëŠ” ê¸°ìˆ ì´ë‹¤.â€*

