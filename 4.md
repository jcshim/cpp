다음은 **4주차: 함수 및 연산자 오버로딩** 강의를 위한 노트 예시입니다.

---

## 강의목표
- **함수 오버로딩 이해**: 동일한 이름의 함수를 매개변수 목록에 따라 여러 버전으로 정의할 수 있는 개념과 원리를 학습합니다.
- **연산자 오버로딩 이해**: 사용자 정의 자료형에 대해 기존 연산자의 동작을 재정의하여 직관적인 연산을 구현하는 방법을 익힙니다.
- **실습을 통한 적용**: 함수 및 연산자 오버로딩을 직접 구현해보며, 오버로딩 원칙과 주의사항을 체득합니다.

---

## 강의요약
이번 강의에서는 C++에서 제공하는 함수 오버로딩과 연산자 오버로딩의 원리를 학습합니다. 함수 오버로딩은 같은 함수 이름으로 서로 다른 매개변수를 가진 함수를 정의하여 코드의 가독성과 재사용성을 높이고, 연산자 오버로딩은 클래스에 내장된 연산자들을 재정의하여 사용자 정의 타입에 맞는 동작을 구현할 수 있게 합니다. 두 개념 모두 컴파일 타임에 결정되며, 올바른 오버로딩을 위해서는 매개변수의 자료형, 개수, 순서 등이 중요합니다.

---

## 강의내용

### 1. 함수 오버로딩
- **개념**:  
  - 하나의 함수 이름으로 서로 다른 매개변수 목록(자료형, 개수, 순서)을 가진 여러 함수를 정의할 수 있습니다.
- **오버로딩 원리**:  
  - 컴파일러는 함수 호출 시 전달된 인자에 맞는 함수 시그니처(함수 이름, 매개변수 타입 및 개수)를 찾아 호출합니다.
- **제약 사항**:  
  - 반환형만 다른 함수는 오버로딩으로 인정되지 않습니다.
  - 명확한 호출이 불가능한 경우 컴파일 오류가 발생할 수 있으므로 주의해야 합니다.

### 2. 연산자 오버로딩
- **개념**:  
  - 연산자 오버로딩은 사용자 정의 타입에 대해 기존 연산자(+, -, << 등)의 동작을 재정의하는 기법입니다.
- **원리 및 방법**:  
  - 클래스 내부에서 멤버 함수 형태로 오버로딩하거나, 외부 함수(보통 friend 함수)로 정의할 수 있습니다.
  - 기존 연산자의 의미를 크게 벗어나지 않도록 설계하는 것이 중요합니다.
- **예시**:  
  - 복소수 클래스(Complex)에서 `operator+`를 오버로딩하여 두 복소수를 더하는 연산을 정의할 수 있습니다.

---

## 실전예제

### 예제 1: 함수 오버로딩

```cpp
#include <iostream>
using namespace std;

// 정수형 덧셈 함수
int add(int a, int b) {
    return a + b;
}

// 실수형 덧셈 함수
double add(double a, double b) {
    return a + b;
}

int main() {
    // 함수 오버로딩을 통한 덧셈 예제
    cout << "정수 덧셈 (3 + 4): " << add(3, 4) << endl;
    cout << "실수 덧셈 (3.5 + 4.5): " << add(3.5, 4.5) << endl;
    return 0;
}
```

**예제 설명**:
- 동일한 `add` 함수 이름을 사용하되, 매개변수 타입에 따라 정수형과 실수형 버전이 정의되어 있습니다.
- 호출 시 인자의 타입에 따라 적절한 함수가 선택되어 실행됩니다.

---

### 예제 2: 연산자 오버로딩 – Complex 클래스

```cpp
#include <iostream>
using namespace std;

class Complex {
private:
    double real, imag;
public:
    // 생성자: 기본값을 0으로 초기화
    Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {}

    // 연산자 오버로딩: operator+를 멤버 함수로 정의
    Complex operator+(const Complex &other) const {
        return Complex(real + other.real, imag + other.imag);
    }

    // 출력 연산자 오버로딩: friend 함수를 사용하여 ostream 출력 지원
    friend ostream& operator<<(ostream &out, const Complex &c) {
        out << c.real << " + " << c.imag << "i";
        return out;
    }
};

int main() {
    Complex c1(3.0, 4.0);
    Complex c2(1.5, 2.5);
    Complex c3 = c1 + c2; // operator+ 호출

    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;
    cout << "c1 + c2: " << c3 << endl;
    return 0;
}
```

**예제 설명**:
- **클래스 정의**: `Complex` 클래스는 실수부와 허수부를 멤버 변수로 가집니다.
- **operator+ 오버로딩**: 두 개의 `Complex` 객체를 더하여 새로운 `Complex` 객체를 반환합니다.
- **operator<< 오버로딩**: 출력 스트림에 `Complex` 객체의 값을 출력할 수 있도록 friend 함수를 사용합니다.
- **실행 결과**: 두 복소수를 더한 결과가 자연스럽게 출력됩니다.

---

이번 강의에서는 함수 및 연산자 오버로딩의 개념과 원리를 실습 예제를 통해 학습합니다. 직접 코드를 작성하고 실행해보면서 오버로딩된 함수나 연산자가 어떻게 선택되고 동작하는지 체험해 보시기 바랍니다.
