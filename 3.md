다음은 **3주차: 객체지향 프로그래밍 II – 상속과 다형성** 강의를 위한 노트 예시입니다.

---

## 강의목표
- **상속 개념 이해**: 기존 클래스의 특성과 기능을 재사용하고 확장하는 상속의 원리를 이해합니다.
- **접근 제어의 역할**: 상속 시 public, protected, private 접근 지정자가 어떻게 작용하는지 파악합니다.
- **가상 함수와 다형성 구현**: 가상 함수를 통한 동적 다형성의 구현 방법과 올바른 함수 호출 메커니즘을 학습합니다.

---

## 강의요약
이번 강의에서는 상속을 통해 기존 클래스의 기능을 재사용하는 방법과, 이를 기반으로 다양한 클래스가 동일한 인터페이스를 공유하는 다형성의 개념을 다룹니다. C++에서 상속 시 접근 지정자의 역할과 가상 함수의 사용법을 살펴보고, 이를 활용한 실제 예제를 통해 객체지향 프로그래밍의 핵심 원리를 이해합니다.

---

## 강의내용

### 1. 상속 (Inheritance)
- **개념**:  
  - 상속은 기존 클래스(기반 클래스, Base Class)의 속성과 기능을 새로운 클래스(파생 클래스, Derived Class)로 확장하여 재사용하는 방법입니다.
- **문법**:  
  - 파생 클래스 선언 시 `class Derived : public Base`와 같이 사용합니다.
- **접근 지정자와 상속**:  
  - **public 상속**: 기반 클래스의 public 멤버는 파생 클래스에서도 public으로 유지, protected 멤버는 그대로 protected로 유지됩니다.
  - **protected 상속**: 기반 클래스의 public 멤버는 파생 클래스에서 protected로 변환됩니다.
  - **private 상속**: 기반 클래스의 public과 protected 멤버 모두 파생 클래스에서 private으로 취급됩니다.

### 2. 가상 함수 (Virtual Functions)
- **목적**:  
  - 가상 함수는 런타임 시에 적절한 파생 클래스의 함수가 호출되도록 하여 다형성을 구현합니다.
- **선언 방법**:  
  - 기본 클래스의 함수 선언 시 `virtual` 키워드를 사용합니다.
- **가상 소멸자**:  
  - 상속 관계에서 파생 클래스 객체를 올바르게 파괴하기 위해 기본 클래스의 소멸자를 가상으로 선언합니다.

### 3. 다형성 (Polymorphism)
- **개념**:  
  - 다형성은 하나의 인터페이스(또는 기본 클래스)를 통해 서로 다른 동작을 구현할 수 있는 기능입니다.
- **동적 다형성**:  
  - 가상 함수를 통해 런타임에 객체의 실제 타입에 맞는 함수가 호출되도록 합니다.
- **장점**:  
  - 코드의 유연성 증가, 확장 및 유지보수가 용이해집니다.

---

## 실전예제

### 예제: Animal 클래스와 파생 클래스(Dog, Cat)를 통한 다형성 구현

```cpp
#include <iostream>
using namespace std;

// 기본 클래스 Animal
class Animal {
public:
    // 가상 함수: 파생 클래스에서 오버라이드하여 각 동물에 맞는 소리를 내게 함
    virtual void speak() {
        cout << "동물이 소리를 냅니다." << endl;
    }
    
    // 가상 소멸자: 올바른 메모리 해제를 위해 필수
    virtual ~Animal() {}
};

// 파생 클래스 Dog
class Dog : public Animal {
public:
    // Dog 클래스에 맞게 speak() 함수 오버라이드
    void speak() override {
        cout << "강아지가 멍멍!" << endl;
    }
};

// 파생 클래스 Cat
class Cat : public Animal {
public:
    // Cat 클래스에 맞게 speak() 함수 오버라이드
    void speak() override {
        cout << "고양이가 야옹!" << endl;
    }
};

int main() {
    // Animal 포인터를 이용한 다형성 예제
    Animal* animals[2];
    
    animals[0] = new Dog();  // Dog 객체 생성
    animals[1] = new Cat();  // Cat 객체 생성
    
    // Animal 포인터 배열을 통해 각 객체의 speak() 호출
    for (int i = 0; i < 2; i++) {
        animals[i]->speak();
    }
    
    // 동적 할당한 메모리 해제
    for (int i = 0; i < 2; i++) {
        delete animals[i];
    }
    
    return 0;
}
```

**예제 설명**:
- **Animal 클래스**:  
  - `speak()` 함수를 가상 함수로 선언하여 파생 클래스에서 각기 다른 동작을 구현할 수 있게 합니다.
  - 가상 소멸자를 통해 동적 할당된 파생 클래스 객체의 소멸 시 올바른 소멸자 호출을 보장합니다.
- **Dog와 Cat 클래스**:  
  - 각각 `speak()` 함수를 오버라이드하여 Dog는 "멍멍", Cat은 "야옹" 소리를 출력합니다.
- **다형성 구현**:  
  - `Animal` 포인터 배열을 사용하여 Dog와 Cat 객체를 저장한 후, 반복문을 통해 `speak()`를 호출하면, 실제 객체 타입에 따라 적절한 함수가 실행됩니다.

---

이번 강의에서는 상속과 다형성을 통해 객체지향 프로그래밍의 핵심 개념을 심화 학습합니다. 학생들은 상속 구조 설계와 가상 함수를 이용한 동적 다형성 구현을 실습하며, 다양한 클래스 간의 관계와 코드 재사용의 장점을 체험해 보시기 바랍니다.
