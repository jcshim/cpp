다음은 **7주차: 최신 C++ 기능 – 람다, auto, 스마트 포인터** 강의를 위한 노트 예시입니다.

---

## 강의목표
- **최신 C++ 기능 이해**: C++11 이후 도입된 새로운 문법과 기능(람다, auto, 스마트 포인터)을 이해하고 활용할 수 있습니다.
- **코드 간결화 및 안전성 향상**: 람다를 통한 함수 객체 간편화, auto를 통한 타입 추론, 스마트 포인터를 통한 메모리 관리 기법을 익힙니다.
- **실습을 통한 적용**: 다양한 예제를 통해 각 기능의 사용법과 장점을 실습해보고, 실제 코드에 적용하는 방법을 체득합니다.

---

## 강의요약
이번 강의에서는 C++11 이후 새롭게 도입된 기능들을 살펴봅니다. 람다 함수는 코드 내에서 간단한 익명 함수 객체를 작성할 수 있게 하며, auto 키워드는 복잡한 타입 선언을 줄여 코드의 가독성을 높입니다. 또한, unique_ptr와 shared_ptr 등 스마트 포인터를 통해 동적 메모리 관리를 안전하고 효율적으로 수행하는 방법을 배웁니다.

---

## 강의내용

### 1. 람다 함수 (Lambda Functions)
- **개념**:  
  - 이름 없이 간단한 함수 객체(익명 함수)를 정의할 수 있는 기능.
  - 주로 짧은 코드나 일회용 함수 객체를 작성할 때 사용.
- **구문**:  
  - `[캡처리스트](매개변수) -> 반환형 { 함수 본문 }`
  - 캡처리스트를 통해 외부 변수를 참조 또는 복사할 수 있음.
- **예제**:  
  - 벡터 정렬, 이벤트 처리, 함수 인자로 전달 등 다양한 용도.

### 2. auto 타입 추론
- **개념**:  
  - 변수 선언 시 자료형을 컴파일러가 자동으로 추론하도록 하여 코드 간결성을 높임.
- **장점**:  
  - 복잡한 자료형(예: STL 컨테이너의 반복자)의 선언을 간편하게 함.
- **사용 예**:  
  - for-each 문, 람다 함수 내부, 복잡한 타입 변수 선언 등.

### 3. 스마트 포인터 (Smart Pointers)
- **개념**:  
  - 동적 메모리 관리를 자동화하여 메모리 누수와 관련된 문제를 줄여주는 포인터 클래스.
- **종류**:
  - **unique_ptr**: 소유권이 단일 객체에 한정되며, 복사 불가능하지만 이동 가능.
  - **shared_ptr**: 여러 포인터가 같은 객체를 공유하며, 참조 카운트 방식으로 관리.
- **사용 예**:  
  - 동적 메모리 할당, 자원 관리, 객체의 수명 관리 등.

---

## 실전예제

### 예제: 람다, auto, 스마트 포인터 활용 예제

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <memory>   // 스마트 포인터 사용을 위한 헤더

using namespace std;

int main() {
    // auto와 람다 함수를 이용한 벡터 정렬 예제
    auto numbers = vector<int>{5, 3, 8, 1, 9};

    // 람다 함수: 두 정수를 비교하여 오름차순 정렬
    sort(numbers.begin(), numbers.end(), [](int a, int b) {
        return a < b;
    });

    cout << "오름차순 정렬된 숫자들: ";
    for (auto n : numbers) {
        cout << n << " ";
    }
    cout << endl;

    // unique_ptr 예제: 동적 메모리 안전 관리
    auto uniqueNum = make_unique<int>(42);
    cout << "unique_ptr가 관리하는 값: " << *uniqueNum << endl;

    // shared_ptr 예제: 참조 카운트 기반 동적 메모리 관리
    auto sharedNum = make_shared<int>(100);
    cout << "초기 shared_ptr 값: " << *sharedNum << ", 참조 카운트: " << sharedNum.use_count() << endl;
    
    {
        // 동일 객체를 가리키는 다른 shared_ptr 생성 (참조 카운트 증가)
        auto sharedNum2 = sharedNum;
        cout << "내부 스코프에서의 참조 카운트: " << sharedNum.use_count() << endl;
    } // sharedNum2 스코프 종료, 참조 카운트 감소

    cout << "내부 스코프 종료 후 참조 카운트: " << sharedNum.use_count() << endl;

    return 0;
}
```

**예제 설명**:
- **람다와 auto 사용**:
  - `numbers` 벡터의 타입을 auto를 이용해 간결하게 선언하였습니다.
  - 람다 함수를 사용해 `sort` 알고리즘 내에서 두 값의 비교를 간단하게 정의합니다.
- **unique_ptr**:
  - `make_unique`를 사용해 동적 할당된 정수 값을 관리하며, 메모리 해제를 자동으로 수행합니다.
- **shared_ptr**:
  - `make_shared`를 통해 생성된 포인터는 참조 카운트를 이용하여 여러 포인터가 같은 객체를 안전하게 공유합니다.
  - 내부 스코프를 통해 참조 카운트의 증가와 감소를 확인할 수 있습니다.

---

이번 강의에서는 최신 C++ 기능을 활용하여 코드의 간결함과 안정성을 높이는 방법을 학습합니다. 예제 코드를 직접 작성하고 실행해보며 람다 함수, auto 타입 추론, 스마트 포인터의 실제 사용법과 그 장점을 체험해 보시기 바랍니다.
